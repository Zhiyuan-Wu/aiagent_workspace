# pair-wise_code_review

alpha_mining/myportfolio.py代码期望直接建模pair-wise的每日股票排序生成，以实现比通过单点预测收益率获得股票排序（alpha_mining/myalpha.py）更好的排序结果。但实现完全错误。

### P0 Issue
1. pair wise rank model中模型推理方法 predict方法实现完全错误，不能是在整个测试集上随机预测一部分样本，然后使用预测结果做排序比赛。而应该是在每一个日期进行排序比赛，在决定了每一轮的比赛对手后，才能动态地构造要进行推理的样本。每一个日期股票的集合、排序过程、最终的股票排序都会不一样。

现在的实现有严重的问题：1. 使用一个预置的随机股票配对（不区分日期）做推理，在固定的推理结果上运行锦标赛排序，不区分日期会导致所有日期的排序结果都一样。2. 现在的实现中，锦标赛会尝试从预先的推理结果中找到对应的股票对，没找到股票对就会跳过这场比赛，不淘汰任何股票，导致while len(alive_stocks) > 1不会退出，陷入死循环。

理想的实现需要在锦标赛过程中为每个日期、每场比赛动态的构造样本进行模型推理。不可能预先获得所有的股票对的预测结果再去排序，平方复杂度不可承受；需要按需推理，但也要考虑汇聚一轮内所有样本做批次推理，来优化推理性能。

2. 锦标赛的实现错误。理想的分数是单纯的获胜轮数，不应该对失败方减1， 也不要对冠军额外+2 ，这会导致分数期望对真实排序不严格单调。直接使用平均的获胜轮数排序可以得到最终排名

3. 训练集pair过滤方法实现错误，不应该是随机生成后再用收益率差距阈值做过滤，有很大的冗余计算，相反，应该在采样时就只采样大于差异分位数的股票对，例如，当过滤百分比为0.8，即需要两只股票分位数差异在0.8以上，那么第一只股票的选择应当在前20%，后一只股票在对应的分位数+0.8后去取。要注意随机交换位置来确保标签平衡。

4. 混合排序方法实现错误，粗排序应该这样得到：随机选取股票对，记录二值化的胜负结果（>0,5胜得一分，<0.5负得-1分）,然后使用积分进行粗排序（不能是原始的模型预测），然后使用粗排序作为初始化排序来进行单淘汰赛，而不是两种方式独立运行后加权结果。

### P1 Issue
1. 重复运行锦标赛需要并行。减少端到端时间。

2. 大量的代码冗余。例如pair wise rank model中fit方法和fit_with_quantile方法是冗余的。

3. 移除循环赛。循环赛的平方复杂度不可接受。

### Suggestion

算法大致以如下过程运行：
1. 在训练集（和验证集）上随机构造训练样本，每个交易日随机生成固定数量的分位数差异大于过滤阈值的样本对，随机交换顺序来保证正负样本平衡
2. 使用训练集训练模型
3. 计算每个交易日的股票排序，以归一化的排序index作为股票的预测信号（排序最高的股票为1，排序最低的股票为0）。预测过程为锦标赛排序：对每个日期运行N次独立的锦标赛，锦标赛每轮的比较股票确定后，调用训练好的模型批量推理比较结果，推理结果>0.5则记为股票A胜利，否则记为股票B胜利，直到完成完整的比赛。注意不同日期的锦标赛、同一日期的不同锦标赛实验、同一锦标赛同一轮次内的独立比较，都可以并行。需要良好的批次推理实现。具体的比赛匹配过程、分数计算、最终排序计算依不同赛制不同，代码中需要实现随机匹配、单淘汰赛、双败淘汰赛、随机匹配初始化的单淘汰赛等不同的赛制，注意不能有平方复杂度的赛制出现。
4. 使用计算好的每个交易日、每个股票的排序信号，计算IC等信号指标。
5. 使用计算好的每个交易日、每个股票的排序信号，使用top-k交易策略执行回测，生成累积收益率曲线，计算年化收益率、夏普比率、最大回撤等回测指标，与沪深300基线对比。
6. 输出所有信号指标、回测指标。
